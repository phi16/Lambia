Pre{
  Func {
    Id = \x.x
    Const = \xy.x
    Compose = \fgx.f (g x)
    Iterate = \nfx.n f x
    Fix = Primitive.Fix
    Flip = \fxy.f y x
    App = \xf.f x
  }
  Combinator {
    I = \x.x
    K = \xy.x
    S = \xyz.x z (y z)
    B = \xyz.x (y z)
    C = \xyz.x z y
    W = \xy.x y y
    X = \x.x S K
    Y = \f.(\x.f (x x)) (\x.f (x x))
    Z = \f.(\x.f (\y.x x y)) (\x.f (\y.x x y))
  }
  Bool {
    True = \xy.x
    False = \xy.y
    And = \pq.p q False
    Or = \pq.p True q
    Not = \pxy.p y x
    If = \pte.p t e
  }
  Pair {
    Pair = \xyp.p x y
    First = \p.p True
    Second = \p.p False

    Swap = \px.p (Not x)
    Curry = \fxy.f (Pair x y)
    Uncurry = \fp.f (First p) (Second p)
  }
  Either {
    Left = \xfg.f x
    Right = \xfg.g x
    Either = \fgp.p f g

    Which = \p.p (\x.False) (\x.True)
  }
  Maybe {
    Nothing = \ef.e
    Just = \xef.f x
    Maybe = \efp.p e f

    Exist = \p.p False (\x.True)
  }
  Nat {
    0 = False
    Succ = \nxy.x (n x y) 
    Add = \mnxy.n x (m x y)
    Mul = \mnx.n (m x)
    Pow = \mn.n m
    Zero = \n.n (\x.False) True

    Pred = \nfx.n (\gh.h (g f)) (\u.x) (\u.u)
    Sub = \mn.n Pred m

    open Primitive.Church
  }
  List {
    Cons = Pair
    Nil = False
    Head = First
    Tail = Second
    Null = \l.l (\xye.False) True
    Fold = Fix (\hfel.If (Null l) e (f (Head l) (h f e (Tail l))))
    Unfold = Fix (\ufe.{
      d = f e
    } Cons (First d) (u f (Second d)))

    Append = Fix (\pab.If (Null a) b (Cons (Head a) (p (Tail a) b)))
    Index = \nl.Head (Iterate n Tail l)
    Map = Fix (\mfl.If (Null l) Nil (Cons (f (Head l)) (m f (Tail l))))
    Nats = Fix (\n.Cons 0 (Map Succ n))
    Length = Fix (\fl.If (Null l) 0 (Succ (f (Tail l))))
  }
  Integer {
    open Primitive.Binary
  }
  Char {
    open Primitive.Char
  }
  Eq {
  }
  Ord {
  }
  Math {
    Church {
    }
    Binary {
    }
  }
  IO {
    open Primitive.IO
  }
}
