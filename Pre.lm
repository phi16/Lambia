Pre {
  open Func {
    Id = \x.x
    Const = \xy.x
    Compose = \fgx.f (g x)
    Fix = \f.(\x.f (x x)) (\x.f (x x))
    Flip = \fxy.f y x
    App = \xf.f x
  }
  Combinator {
    I = \x.x
    K = \xy.x
    S = \xyz.x z (y z)
    B = \xyz.x (y z)
    C = \xyz.x z y
    W = \xy.x y y
    X = \x.x S K
    Y = \f.(\x.f (x x)) (\x.f (x x))
  }
  open Bool {
    True = \xy.x
    False = \xy.y
    And = \pq.p q False
    Or = \pq.p True q
    Not = \pxy.p y x
    Xor = \pq.p (\xy.q y x) q
    If = \pte.p t e
  }
  open Pair {
    Pair = \xyp.p x y
    First = \p.p True
    Second = \p.p False

    Swap = \px.p (Not x)
    Curry = \fxy.f (Pair x y)
    Uncurry = \fp.f (First p) (Second p)
  }
  open Either {
    Left = \xfg.f x
    Right = \xfg.g x
    Either = \fgp.p f g

    Which = \p.p (\x.False) (\x.True)
  }
  open Maybe {
    Nothing = \ef.e
    Just = \xef.f x
    Maybe = \efp.p e f

    Exist = \p.p False (\x.True)
  }
  open Nat {
    0 = False
    Succ = \nxy.x (n x y) 
    Iterate = \nfx.n f x

    Add = \mnxy.n x (m x y)
    Mul = \mnx.n (m x)
    Pow = \mn.n m
    Zero = \n.n (\x.False) True

    Pred = \nfx.n (\gh.h (g f)) (\u.x) (\u.u)
    Sub = \mn.n Pred m
    Div = \pq.Fix (\dxy.{
      u = Sub x y
    } If (Zero u) 0 (Succ (d u y))) (Succ p) q
    Mod = \pq.Pred (Fix (\mxy.{
      u = Sub x y
    } If (Zero u) x (m u y)) (Succ p) q)

    open Primitive.Nat
  }
  open List {
    Cons = Pair
    Nil = False
    Head = First
    Tail = Second
    Null = \l.l (\xye.False) True
    Fold = Fix (\hfel.If (Null l) e (f (Head l) (h f e (Tail l))))
    Unfold = Fix (\ufe.{
      d = f e
    } Cons (First d) (u f (Second d)))

    Append = Fix (\pab.If (Null a) b (Cons (Head a) (p (Tail a) b)))
    Index = \nl.Head (Iterate n Tail l)
    Map = Fix (\mfl.If (Null l) Nil (Cons (f (Head l)) (m f (Tail l))))
    Nats = Fix (\n.Cons 0 (Map Succ n))
    Length = Fix (\fl.If (Null l) 0 (Succ (f (Tail l))))
    Zip = Fix (\zfab.If (Or (Null a) (Null b)) Nil ({
      h = f (Head a) (Head b)
      t = z f (Tail a) (Tail b)
    } Cons h t))

    Left {
      Cons = \xsfe.f x (s f e)
      Nil = False
      Head = \s.s (\xy.x) False
      Tail = \scn.s (\htg.g h (t c)) (\t.n) (\ht.t)
      Null = \l.l (\xy.False) True
      Fold = \sfe.s f e
    }
  }
  Binary {
    B = False
    I = \pq.q True p
    O = \pq.q False p
    End = Null
    Digit = Length
    Bit {
      And = Zip And
      Or = Zip Or
      Not = \b.Map Not b
      Xor = Zip Xor
    }
  }
  Integer {
    open Primitive.Integer
  }
  Char {
    open Primitive.Char
  }
  Decimal {
    open Primitive.Decimal
  }
  Eq {
    Nat = \mn.And (Zero (Sub m n)) (Zero (Sub n m))
  }
  open IO {
    open Primitive.IO
  }
}
Verify {
  open Pre
  1 = Succ 0
  2 = Succ 1
  3 = Succ 2
  4 = Succ 3
  5 = Succ 4
  6 = Succ 5
  7 = Succ 6
  Fact = Fix (\fn.If (Zero n) (Succ 0) (Mul n (f (Pred n))))

  V0 = Eq.Nat 3 (Add 2 1)
  V1 = Eq.Nat 6 (Mul (Sub 3 1) (Mod 7 4))
  V2 = Eq.Nat 6 (Fact (Succ (Succ (Succ 0))))
  V3 = Eq.Nat 7 (Add (Mul (Div 7 3) 3) (Mod 7 3))
}
open Verify
And (And (And V0 V1) V2) V3
