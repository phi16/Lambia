Pre {
  open Func {
    Id = \x.x : a -> a
    Const = \xy.x : a -> b -> a
    Compose = \fgx.f (g x) : (b -> c) -> (a -> b) -> a -> c
    Fix = \f.(\x.f (x x)) (\x.f (x x)) : (a -> a) -> a
    Flip = \fxy.f y x : (a -> b -> c) -> b -> a -> c
    App = \fx.f x : (a -> b) -> a -> b
    Give = \xf.f x : a -> (a -> b) -> b
  }
  Combinator {
    I = \x.x : a -> a
    K = \xy.x : a -> b -> a
    S = \xyz.x z (y z) : (a -> b -> c) -> (a -> b) -> a -> c
    B = \xyz.x (y z) : (b -> c) -> (a -> b) -> a -> c
    C = \xyz.x z y : (a -> b -> c) -> b -> a -> c
    W = \xy.x y y : (a -> a -> b) -> a -> b
    X = \x.x S K : (((a -> b -> c) -> (a -> b) -> a -> c) -> (d -> e -> d) -> f) -> f
    Y = \f.(\x.f (x x)) (\x.f (x x)) : (a -> a) -> a
  }
  open Bool {
    True = \xy.x : Bool
    False = \xy.y : Bool
    And = \pq.p q False : Bool -> Bool -> Bool
    Or = \pq.p True q : Bool -> Bool -> Bool
    Not = \pxy.p y x : Bool -> Bool
    Xor = \pq.p (Not q) q : Bool -> Bool -> Bool
    Eqv = \pq.p q (Not q) : Bool -> Bool -> Bool
    If = \pte.p t e : Bool -> a -> a -> a
  }
  open Pair {
    Pair = \xyp.p x y : a -> b -> Pair a b
    Fst = \p.p True : Pair a b -> a
    Snd = \p.p False : Pair a b -> b

    Swap = \px.p (Not x) : Pair a b -> Pair b a
    Curry = \fxy.f (Pair x y) : (Pair a b -> c) -> a -> b -> c
    Uncurry = \fp.f (Fst p) (Snd p) : (a -> b -> c) -> Pair a b -> c
    First = \fpd.d (f (Fst p)) (Snd p)
    Second = \fpd.d (Fst p) (f (Snd p))
  }
  open Either {
    Left = \xfg.f x : a -> Either a b
    Right = \xfg.g x : b -> Either a b
    Either = \fgp.p f g : (a -> c) -> (b -> c) -> Either a b -> c

    Which = \p.p (\x.False) (\x.True) : Either a b -> Bool
  }
  open Maybe {
    Nothing = \fe.e : Maybe a
    Just = \xfe.f x : a -> Maybe a
    Maybe = \fep.p f e : (a -> b) -> b ->  Maybe a -> b

    Exist = \p.p False (\x.True) : Maybe a -> Bool
  }
  open Nat {
    0 = \xy.y : Nat
    Succ = \nxy.x (n x y) : Nat -> Nat 
    Iterate = \nfx.n f x : Nat -> (a -> a) -> a -> a

    Add = \mnxy.n x (m x y) : Nat -> Nat -> Nat
    Mul = \mnx.n (m x) : Nat -> Nat -> Nat
    Pow = \mn.n m : Nat -> Nat -> Nat
    Zero = \n.n (\x.False) True : Nat -> Bool

    Pred = \nfx.n (\gh.h (g f)) (\u.x) (\u.u) : Nat -> Nat
    Sub = \mn.n Pred m : Nat -> Nat -> Nat
    Div = \pq.Fix (\dxy.{
      u = Sub x y
    } If (Zero u) 0 (Succ (d u y))) (Succ p) q : Nat -> Nat -> Nat
    Mod = \pq.Pred (Fix (\mxy.{
      u = Sub x y
    } If (Zero u) x (m u y)) (Succ p) q) : Nat -> Nat -> Nat

    Le = \mn.Zero (Sub m n) : Nat -> Nat -> Bool
    Lt = \mn.Zero (Sub (Succ m) n) : Nat -> Nat -> Bool
    Ge = \mn.Zero (Sub n m) : Nat -> Nat -> Bool
    Gt = \mn.Zero (Sub (Succ n) m) : Nat -> Nat -> Bool
    Eq = \mn.And (Le m n) (Ge m n) : Nat -> Nat -> Bool

    open Primitive.Nat
    1 = Succ 0
    2 = Succ 1
    3 = Succ 2
    4 = Succ 3
    5 = Succ 4
    6 = Succ 5
    7 = Succ 6
  }
  Int {
    FromNat = \n.Pair n 0 : Nat -> Int
    O = FromNat 0 : Int
    Normalize = \n.{
      f = Fst n
      s = Snd n
    } If (Ge f s) (Pair (Sub f s) 0) (Pair 0 (Sub s f)) : Int -> Int
    ToNat = \n.Fst (Normalize n) : Int -> Nat
    Abs = \n.Uncurry Add (Normalize n) : Int -> Nat
    Pos = \n.Gt (Fst n) (Snd n) : Int -> Bool
    Neg = \n.Lt (Fst n) (Snd n) : Int -> Bool
    Z = \n.Eq (Fst n) (Snd n) : Int -> Bool
    Negate = Swap : Int -> Int

    Plus = \mn.Pair (Add (Fst m) (Fst n)) (Add (Snd m) (Snd n)) : Int -> Int -> Int
    Minus = \mn.Pair (Add (Fst m) (Snd n)) (Add (Snd m) (Fst n)) : Int -> Int -> Int
    Mult = \mn.{
      a = Fst m
      b = Snd m
      c = Fst n
      d = Snd n
    } Pair (Add (Mul a c) (Mul b d)) (Add (Mul a d) (Mul b c)) : Int -> Int -> Int
    Divide = \xy.{
      D = \mn.{
        d = FromNat (Div (Abs m) (Abs n))
        e = Eqv (Pos m) (Pos n)
      } If e d (Negate d)
    } D (Normalize x) (Normalize y) : Int -> Int -> Int

    open Primitive.Int
  }
  open List {
    Left {
      Cons = \xsfe.f x (s f e) : a -> List a -> List a
      Snoc = \xsfe.s f (f x e) : a -> List a -> List a
      Nil = \fe.e : List a
      Head = \s.s (\xy.x) False : List a -> a
      Tail = \scn.s (\htg.g h (t c)) (\t.n) (\ht.t) : List a -> List a
      Null = \l.l (\xy.False) True : List a -> Bool
      Fold = \fes.s f e : (a -> b -> a) -> b -> List a -> b
    }
    Right {
      Cons = Pair : a -> List a -> List a
      Nil = \xy.y : List a
      Head = Fst : List a -> a
      Tail = Snd : List a -> List a
      Null = \l.l (\xye.False) True : List a -> Bool
      Fold = Fix (\hfel.If (Null l) e (f (Head l) (h f e (Tail l)))) : (a -> b -> a) -> b -> List a -> b
    }
    open Left

    Unfold = Fix (\ufe.{
      d = f e
    } Second (u f) d) : (a -> Pair b a) -> a -> List b
    Append = \ab.Fold Cons b a : List a -> List a -> List a
    Index = \nl.Head (Iterate n Tail l) : Int -> List a -> a
    Map = \f.Fold (\pq.Cons (f p) q) Nil : (a -> b) -> List a -> List b
    Nats = Fix (\n.Cons 0 (Map Succ n)) : List Nat
    Length = Fold (Const Succ) 0 : List a -> Nat
    Zip = Fix (\zfab.If (Or (Null a) (Null b)) Nil ({
      h = f (Head a) (Head b)
      t = z f (Tail a) (Tail b)
    } Cons h t)) : (a -> b -> c) -> List a -> List b -> List c
    Take = Fix (\tnl.If (Or (Zero n) (Null l)) Nil (Cons (Head l) (t (Pred n) (Tail l)))) : Int -> List a -> List a
    Drop = Fix (\tnl.If (Or (Zero n) (Null l)) l (t (Pred n) (Tail l))) : Int -> List a -> List a
    Split = Fix (\snl.If (Or (Zero n) (Null l)) (Pair Nil l) ({
      r = s (Pred n) (Tail l)
    } Pair (Cons (Head l) (Fst r)) (Snd r))) : Int -> List a -> Pair (List a) (List a)
    Filter = \f.Fold (\pq.(If (f p) (Cons p) Id) q) Nil : (a -> Bool) -> List a -> List a
    Partition = \f.{
      pred = \pq.(If (f p) First Second) (Cons p) q
    } Fold pred (Pair Nil Nil) : (a -> Bool) -> List a -> Pair (List a) (List a)
    Sort = Fix (\sl.If (Null l) Nil ({
      h = Head l
      t = Tail l
      u = Partition (Ge h) t
      la = s (Fst u)
      ra = Cons h (s (Snd u))
    } If (Null t) (Cons h Nil) (Append la ra))) : List Nat -> List Nat

    [ = \ec.c (Left.Cons e Left.Nil) : a -> (Left.List a -> b) -> b
    , = \lec.c (Left.Snoc e l) : Left.List a -> a -> (Left.List a -> b) -> b
    ] = \lc.c l : List a -> (Left.List a -> b) -> b
    AsList = \l.l Cons Nil : Left.List a -> List a
    AsFold = \l.l : Left.List a -> (a -> b -> a) -> b -> b
  }
  Binary {
    B = Nil : Binary
    I = \p.Cons True p : Binary -> Binary
    O = \p.Cons False p : Binary -> Binary
    End = Null : Binary -> Bool
    Digit = Length : Binary -> Nat
    Bit {
      And = Zip And : Binary -> Binary -> Binary
      Or = Zip Or : Binary -> Binary -> Binary
      Not = \b.Map Not b : Binary -> Binary
      Xor = Zip Xor : Binary -> Binary -> Binary
    }
    Nat = {
      c = \xy.Add (Mul 2 y) (If x 1 0) : Nat -> Bool -> Nat
    } Fold c 0 : Binary -> Nat
  }
  Integer {
    open Primitive.Integer
  }
  Char {
    open Primitive.Char
  }
  Decimal {
    open Primitive.Decimal
  }
  open IO {
    open Primitive.IO
  }
}
Verify {
  open Pre
  Fact = Fix (\fn.If (Zero n) 1 (Mul n (f (Pred n))))

  N0 = Eq 3 (Add 2 1)
  N1 = Eq 6 (Mul (Sub 3 1) (Mod 7 4))
  N2 = Eq 6 (Fact 3)
  N3 = Eq 7 (Add (Mul (Div 7 3) 3) (Mod 7 3))
  N4 = Eq 6 ([ 1 , 2 , 3 ] AsFold Add False)
  N = [ N0 , N1 , N2 , N3 , N4 ] AsFold And True

  l = [ 3 , 2 , 5 , 1 , 4 ] AsList
  L0 = Eq 5 (Length l)
  L1 = Eq (Mul 3 5) (Fold Add 0 l)
  L2 = Fold And True (Zip Eq (Take 5 (Tail Nats)) (Sort l))
  L = [ L0 , L1 , L2 ] AsFold And True

  open Binary
  B0 = Eq (Mul 3 3) (Nat ([ I , O , O , I ] AsFold App B))
  B = [ B0 ] AsFold And True

  Verified = [ N , L , B ] AsFold And True
}
Verify.Verified
